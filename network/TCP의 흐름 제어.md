#tcp 
### 출처
* https://evan-moon.github.io/2019/11/22/tcp-flow-control-error-control/ (TCP의 흐름제어)
___
### 개요
* [[#TCP의 흐름제어]]
* [[#Stop and Wait]]
* [[#Sliding Window]]
* [[#오류 제어]]
* [[#Go Back N]]
* [[#Selective Repeat]]
___
### TCP의 흐름제어

네트워크를 통해 통신하는 송, 수신측의 어플리케이션의 상태는 유동적이다. 프로세스 실행 중 블락이나 메모리 부족 등의 상황이 발생할 수 있고 이에 영향을 받아 송 수신 속도가 변화 할 수 있다. 이때 **데이터 수신 측에 부하가 발생할 경우 처리 속도가 감소하며 데이터가 버퍼를 가득 채우고 이후 버려지는 현상**을 확인 할 수 있다. 

TCP는 전송의 신뢰성을 보장해야 하기에 이를 방지하기 위해 꾸준히 송신 측에게 자신의 처리 상태를 알려야 한다. <span class="red red-bg"><b>TCP의 흐름제어는 이를 위해 사용하는 기법으로 상대방의 처리 속도와 네트워크 상황 등을 파악해 데이터의 전송 속도를 적절히 설정하는 기법들을 말한다.</b></span>

데이터 수신 측은 [[TCP 첫 걸음#TCP 세그먼트|TCP 세그먼트]]에 존재하는 윈도우 사이즈 값을 통해 현재의 처리 속도 및 버퍼의 현황을 송신 측에 전송하고 전송 측은 수신 측의 정보와 네트워크 상황을 참조해고 데이터 전송 속도를 조절한다.  
___
### Stop and Wait

![300](https://evan-moon.github.io/static/65ff8e861f0894835574fb210cb11888/6af66/stop-and-wait.png)

캐치볼과 같은 방법으로 보낸 패킷에 대한 응답 패킷이 와야 다음 패킷을 전송하는 방법을 말한다. 데이터 전송을 보장할 수 있는 직관적인 방법이다. 하지만 **한번에 한개씩 만 전송이 가능하기 때문에 병렬성을 전혀 활용하지 못하는 비효율적인 전송 방식이다.**

![](https://obs3dian.s3.ap-northeast-2.amazonaws.com/TCP%EC%9D%98%20%ED%9D%90%EB%A6%84%20%EC%A0%9C%EC%96%B4%20/%20Pasted%20image%2020240501120759.png)

스탑-웨이트 방식은 0과 1로만 구성된 버퍼를 활용해 통신을 진행한다. 이러한 방식으로 구현한 까닭은 **현재 내가 수신할 데이터와 직전에 수신한 데이터 외의 다른 요소에는 관심이 없기 때문**이다. 현재 수신할 데이터가 1, 직전에 수신한 데이터가 0이라고 가정하면 ACK 1은  현재 패킷을 전송 하라는 의미이고 ACK 0은 직전 패킷을 재전송 하라는 의미가 된다.

스탑-웨이트는 구현도 단순하고 버퍼의 크기도 작다. (버퍼의 각 공간이 1비트 이므로) 하지만 앞서 말했듯 한번에 한개의 패킷 밖에 전송하지 못하기 때문에 ==**네트워크 대역폭의 낭비가 심하고 전송 속도가 느리다는 단점이 극명해 특수한 상황에서만 활용한다.**==
___
### Sliding Window

**슬라이딩 윈도우는 수신 측이 한번에 처리할 수 있는 데이터를 정해놓고 이를 송신 측에 전송해 상태를 알려주는 방식**이다. 해당 방식의 장점은 <b><u>윈도우 크기 만큼의 데이터는 응답 없이 전송 받을 수 있기 때문에 연속성을 보장할 수 있다는 점</u></b>이다. 이렇게 연속적으로 패킷을 보내는 방식을 패킷 파이프라이닝이라 부르며 빠른 속도로 전송을 진행할 수 있다.

슬라이딩 윈도우는 연속해서 데이터를 전송하기 때문에 이를 정렬하고 중간에 전송 실패한 패킷이 존재할 때 별도의 처리가 필요하다. 이하에서는 슬라이딩 윈도우의 동작 방식에 대해 설명한다.

**윈도우 사이즈는 네트워크 환경과 수신 측의 상황에 영향을 받아 계속해서 크기가 변화**한다. 초기 윈도우 사이즈는 핸드 쉐이크를 통해 커넥션을 수립할 때 설정되며 이후 RTT 값 등에 영향을 받아 변화한다.

슬라이딩 윈도우라는 이름이 붙은 이유는 정해진 윈도우 크기 만큼의 데이터를 계속해서 이동 시키면서 전송하기 때문이다. 아래의 이미지를 살펴보면 응답이 올 때마다 윈도우를 밀며 전송하는 방식을 확인할 수 있다. ACK 2가 왔을 때 송신 측은 윈도우를 2의 위치까지 이동시키고 다시 전송을 진행한다.

![](https://obs3dian.s3.ap-northeast-2.amazonaws.com/TCP%EC%9D%98%20%ED%9D%90%EB%A6%84%20%EC%A0%9C%EC%96%B4%20/%20Pasted%20image%2020231227161028.png)

**슬라이딩 윈도우는 ACK를 받은 패킷을 기준으로 윈도우 사이즈 만큼 전송하고 윈도우를 미는 행위를 반복하며 패킷을 연속 전송한다**. 이때 네트워크 환경에 맞춰 윈도우 사이즈를 조절하는 작업도 같이 진행한다.

![500](https://obs3dian.s3.ap-northeast-2.amazonaws.com/TCP%EC%9D%98%20%ED%9D%90%EB%A6%84%20%EC%A0%9C%EC%96%B4%20/%20Pasted%20image%2020231227161358%201.png)

슬라이딩 윈도우의 최대 크기는 65355 bytes로 제법 큰 크기가 된다. **큰 크기의 바이트를 응답 없이 연속 전송할 수 있기 때문에 슬라이딩 윈도우는 Stop-and-Wait 방식에 비해 속도가 빠르다. 또한 네트워크 환경이나 상황에 맞춰 윈도우 사이즈로 대응이 가능**하므로 현재의 TCP는 전부 슬라이딩 윈도우 방식을 채택하고 있다.
___
### 오류 제어

<span class="red red-bg"><b>TCP는 기본적으로 재전송을 통해 오류를 해결한다. 하지만 재전송 작업 자체의 오버헤드가 꽤 크기 때문에 최대한 재전송을 방지하는 것을 목표로 여러가지 방법을 사용한다.</b></span>

**재전송이 발생하는 경우는 응답이 타임아웃이 지나도록 돌아오지 않을 때 혹은 명시적으로 NACK가 올 때 혹은 중복된 ACK가 오는 경우 등이 존재한다**. 이때 NACK를 사용하면 NACK에 대한 ACK 처리를 별도로 작업해야 하기에 ACK만을 활용해 오류 감지를 하고 재전송을 진행한다.
___
### Go Back N

Go Back N 방식은 Stop-and-Wait 방식의 속도가 느리다는 단점을 해결한 방식으로 ==**한번에 윈도우 사이즈 만큼의 패킷을 전송**==한다. 

![500](https://obs3dian.s3.ap-northeast-2.amazonaws.com/TCP%EC%9D%98%20%ED%9D%90%EB%A6%84%20%EC%A0%9C%EC%96%B4%20/%20Pasted%20image%2020231227165039.png)

하나의 패킷을 전송하고 ACK를 기다리는 방식이 아니라 여러 패킷을 연속적으로 전송하고 Cumulative한 ACK를 전송하기 때문에 네트워크를 더욱 효율적으로 활용할 수 있다. <b><u>Go Back N은 순서를 보장하는 방식으로 데이터를 수신하기 때문에 만약 전송에 오류가 발생하면 이전까지 받은 데이터를 전부 폐기하고 전체를 재 수신 받는다.</u></b> 

위의 예제에서도 확인할 수 있듯이 **패킷 3,4,5가 정상적으로 전달 됐음에도 패킷2가 전달되지 않아.  3,4,5 패킷을 전부 버리고  패킷 2부터 데이터를 전부 재전송한다. 따라서 수신 버퍼에는 항상 순서가 명확하게 정렬된 데이터만 존재한다.**

Cumulative ACK 속성 또한 여기서 유래된 속성으로 **타임아웃이 발생하지 않는 이상 이전의 ACK가 소실돼도 이후의 ACK가 정상적으로 전송되면 전송을 이어서 진행할 수있다**. 이는 **ACK가 특정 패킷의 전송만을 보장하는 것이 아니라 해당 ACK 이전까지의 전송이 정상적으로 완료 됐다는 것을 내포하기 때문**이다.

![](https://obs3dian.s3.ap-northeast-2.amazonaws.com/TCP%EC%9D%98%20%ED%9D%90%EB%A6%84%20%EC%A0%9C%EC%96%B4%20/%20Pasted%20image%2020240501142249.png)

해당 이미지에서 확인할 수 있듯이 **ACK2에서 소실이 발생하더라도 이후에 전송된 ACK3이 정상적으로 전송 되면서 이전 2번 패킷의 정상 전송을 보장하기 때문에 ACK2의 소실이 큰 영향을 끼치지 않는다.** 

> [!info]
><b><u>Go Back N 방식은 오류가 발생한 부분 부터 재전송을 진행하는 방식이다. 수신 측은 오류가 발생한 지점 이후의 패킷을 전부 폐기 처리하고 전체를 다시 재전송 받는다. </b></u>연속적으로 데이터를 보내는 슬라이딩 윈도우 방식과 잘 맞는 방식이다.


![400](https://obs3dian.s3.ap-northeast-2.amazonaws.com/TCP%EC%9D%98%20%ED%9D%90%EB%A6%84%20%EC%A0%9C%EC%96%B4%20/%20Pasted%20image%2020240501143228.png)

Go-Back-N 방식을 활용할 경우 시퀀스 번호와 윈도우 사이즈를 활용해 전송을 진행한다. 이때 시퀀스 번호는 전송하는 패킷의 번호를 의미하고 윈도우 크기는 한번에 전송하는 데이터의 크기를 의미한다. **이때 시퀀스 번호를 표현 하는데 필요한 비트 수를 m이라고 할때 `2^m-1` 이 최대 윈도우 크기이다.** 이 경우 윈도우의 시퀀스 번호가 0, 1, 2만 반복하고 3까지 진행되지 못하므로 다시 전송 패킷이 0으로 넘어가는 사이클이 발생하지 않는다. 이에 따라 각 ACK를 명확히 구분하는 것이 가능해진다.

==**윈도우 사이즈가 해당 크기보다 클 경우 시퀀스 번호에 중복이 발생하며 문제가 발생할 수 있다.**== 아래는 **모든 ACK의 전송이 실패한 경우다. 이에 따라 타임아웃 발생시 수신자는 동일한 윈도우를 재 송신한다.**

![400](https://obs3dian.s3.ap-northeast-2.amazonaws.com/TCP%EC%9D%98%20%ED%9D%90%EB%A6%84%20%EC%A0%9C%EC%96%B4%20/%20Pasted%20image%2020240501144136.png)

위의 이미지를 확인 해보면 0, 1, 2, 3 패킷을 동시에 전송하고 모든 ACK가 실패한 것을 확인할 수 있다. <b><u>이후 패킷을 재전송하는데 이때 수신자가 재전송한 0번 패킷을 기존의 패킷과 명확히 구분할 수 없기 때문에 중복 오류가 발생한다.</u></b> 
![](https://obs3dian.s3.ap-northeast-2.amazonaws.com/TCP%EC%9D%98%20%ED%9D%90%EB%A6%84%20%EC%A0%9C%EC%96%B4%20/%20%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-05-01%20%EC%98%A4%ED%9B%84%2011.46.39.png)

**송신자는 0,1,2,3을 다시 전송하고 수신자는 2번째 0번 패킷을 대기하게 된다. 이에따라 중복 전송에 따른 처리 오류가 유발될 수 있다.** 이때 만약 윈도우 사이즈가 시퀀스 번호의 수보다 작다면, **재전송을 하더라도 0,1,2만 다시 전송하고 3을 전송 받지 못하므로 중복 오류가 발생하지 않는다.**
___ 
### Selective Repeat

**Go Back N의 단점을 개선해 에러가 발생한 부분만 재전송 하는 방법**이다. 재전송의 크기는 Go Back N 보다 작지만, **오류가 난 패킷만 다시 전송하기에 패킷이 순차대로 저장되지 않는 문제가 발생**한다. 따라서 **순서를 보장하기 위해선 별도의 버퍼에서 데이터를 정렬**해야한다. 만약 정렬 작업의 오버헤드가 더 큰 경우 Go Back N을 사용하는 것이 더 유리할 수 있다.

![400](https://obs3dian.s3.ap-northeast-2.amazonaws.com/TCP%EC%9D%98%20%ED%9D%90%EB%A6%84%20%EC%A0%9C%EC%96%B4%20/%20Pasted%20image%2020231227165628.png)

![500](https://obs3dian.s3.ap-northeast-2.amazonaws.com/TCP%EC%9D%98%20%ED%9D%90%EB%A6%84%20%EC%A0%9C%EC%96%B4%20/%20Pasted%20image%2020240501173959.png)

Selective Repeat 방식 또한 Go-Back-N과 마찬가지로 윈도우 크기 만큼 데이터를 전송하는 방식으로 동작한다. 하지만 **이미지에서 확인 할 수 있듯 패킷 1번의 손실이 발생해도 먼저 도착한 2,3 패킷을 버리지 않고 버퍼에 저장해뒀다가 1번을 다시 요청하고 1번이 도착하면 이후 정렬해서 관리**한다. 특정 패킷에 대한 ACK 응답이 타임아웃이 발생할 때까지 수신되지 않는 경우 재전송을 실시한다.

이는 주요한 특징으로 ==**수신 측은 윈도우에 속한 패킷을 받을 때마다 윈도우를 한칸 씩 미는 방식으로 동작한다. 만약 윈도우에 존재하지 않는 패킷이 전송되는 경우에만 패킷을 버린다.**==

![400](https://obs3dian.s3.ap-northeast-2.amazonaws.com/TCP%EC%9D%98%20%ED%9D%90%EB%A6%84%20%EC%A0%9C%EC%96%B4%20/%20Pasted%20image%2020240501181404.png)

**Selective-Repeat의 경우 윈도우의 크기가 시퀀스 번호의 절반을 초과하면 안된다**. 윈도우 사이즈가 만약 절반을 넘어갈 경우 수신자 측에서 ACK를 확인할 수신 측의 윈도우가 다음 사이클로 넘어갈 수 있기 때문이다.

위의 이미지에서도 수신 측에서 윈도우를 꾸준히 밀다보면 **윈도우가 다음 사이클의 0,1까지 침범하는 것을 확인할 수 있다. 이 경우 수신자 측에서 전송하는 재전송하는 패킷을 구분하는 것이 어려워진다.** 

**Selective-Repeat의 경우 윈도우에 포함 되기만 하면 윈도우를 밀 수 있다. 이에 따라 수신해서 처리한 패킷과 윈도우에 존재하는 수신할 패킷의 중복을 방지하기 위해서는 윈도우 사이즈가 전체 시퀀스 번호의 절반이하여야 한다.** 송신하는 패킷은 윈도우 사이즈만큼 전송 되므로 수신 측에서는 수신한 패킷이 윈도우 사이즈만큼 존재하고 수신할 패킷이 윈도우 사이즈 만큼 존재하게 된다. 

![400](https://obs3dian.s3.ap-northeast-2.amazonaws.com/TCP%EC%9D%98%20%ED%9D%90%EB%A6%84%20%EC%A0%9C%EC%96%B4%20/%20Pasted%20image%2020240501181721.png)
