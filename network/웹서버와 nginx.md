### 출처
* [nginx의 구조](https://haon.blog/infra/nginx/core-concept/)
* [nginx의 장단점](https://ssdragon.tistory.com/60)
* [nginx 정적 컨텐츠 설정](https://soojong.tistory.com/entry/Nginx%EB%A1%9C-%EC%A0%95%EC%A0%81-%EC%BB%A8%ED%85%90%EC%B8%A0-%EC%A0%9C%EA%B3%B5%ED%95%98%EA%B8%B0)
___
### 개요
* [[#웹서버란]]
* [[#웹 서버가 수행해야하는 일]]
* [[#요청 메시지 수신]]
* [[#웹서버 아키텍쳐]]
* [[#nginx란?]]
* [[#nginx 구조 맛보기]]
* [[#nginx의 장,단점]]
* [[#nginx로 웹 서버 만들기]]
* [[#정적 웹서버의 한계]]
___
### 웹서버란

<span class="red red-bg"><b>웹서버는 HTTP 요청을 처리하고 응답을 제공하는 서버이다. TCP와 HTTP 처리를 담당하며 리소스를 관리하는 역할을 수행한다. </b></span> 이론상 정적인 파일만 전달하는 우리가 만들었던 [[싱글 스레드 기반의 초간단 정적 웹서버 만들기|과제]] 또한 웹서버로 분류할 수는 있다.

웹서버는 실제 웹 서비스를 동작하는 하드웨어 서비스를 의미하기도 하고 HTTP 요청을 처리하는 소프트웨어를 칭하기도 한다. 현재 소프트웨어 웹서버는 다양하게 존재하며 현재 `nginx`와 `Apache`가 양분하고 있다.

![](https://obs3dian.s3.ap-northeast-2.amazonaws.com/%EC%9B%B9%EC%84%9C%EB%B2%84%EC%99%80%20WAS%20/%20%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-01-14%20%EC%98%A4%ED%9B%84%205.42.09.png)

소프트웨어 웹서버는 주로 파일 제공 등의 정적인 요청을 처리하는 서버를 의미하며 동적인 처리가 필요한 경우 별도의 WAS 서버를 활용한다. 

___
### 웹 서버가 수행해야하는 일

1. 커넥션을 맺어 클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다
2. 요청을 수신해 HTTP 요청 메세지를 네트워크로 부터 읽어들인다
3. 요청 메세지를 해석하고 행동을 취한다
4. 메시지에서 지정한 리소스에 접근한다
5. 응답을 만들어 올바른 헤더를 포함한 HTTP 응답메세지를 생성한다
6. 응답을 클라이언트에게 돌려준다
7. 로그 파일에 트랜잭션 완료에 대한 기록을 남긴다

웹서버가 기본적으로 수행해야할 작업들은 위의 7가지이다. 이 정도만 돼도 웹서버라고 칭할 수 있다.

![500](https://obs3dian.s3.ap-northeast-2.amazonaws.com/%EC%9B%B9%EC%84%9C%EB%B2%84%EC%99%80%20WAS%20/%20Pasted%20image%2020240114175705.png)

>[!info]
>**TCP 커넥션을 맺고 HTTP 요청의 처리 및 적절한 전송이 가능하면 웹 서버라고 할 수 있다.**

___
### 요청 메시지 수신

**커넥션에 데이터가 도착하면 웹 서버는 커넥션에서 데이터를 읽고 파싱해 요청 메시지를 구성한다.**
**요청 메시지를 식별하는 방법은 다음과 같다.**

- 요청 메세지를 파싱할때, 웹 서버는 무엇을 할까?
    1. 요청 메서드, 지정된 리소스의 식별자(URI), 버전 번호를 찾는다. 각 값은 스페이스 하나로 분리되어 있으며, 요청줄은 캐리지 리턴 줄바꿈(CRLF) 문자열로 끝난다
    2. 메세지의 헤더를 읽는다. 역시 CRLF로 끝난다
    3. 헤더의 끝을 의미하는 CRLF로 끝나는 빈 줄을 찾아낸다
    4. 요청 본문이 있다면, 읽어들인다.

네트워크 상황에 따라 입력 데이터를 불규칙적으로 받고 언제라도 무효화 될 수 있다. 따라서 **웹 서버는 파싱을 통해 이해하는 것이 가능한 수준의 분량을 확보할 때까지 데이터를 네트워크로 부터 읽어서 메시지 일부분을 메모리에 임시로 저장해 둘 필요가 있다.** 단순히 전송이 성공했다는 것을 확인할 것이 아니라 메시지가 정확히 도착했다는 것을 확인해야하기 때문이다.
___
#### 웹서버 아키텍쳐

![500](https://obs3dian.s3.ap-northeast-2.amazonaws.com/%EC%9B%B9%EC%84%9C%EB%B2%84%EC%99%80%20WAS%20/%20Pasted%20image%2020240114181540.png)


* **단일 스레드 IO 서버**
	단일한 스레드를 통해 동기적으로 요청을 처리한다. 가장 단순하지만, 응답성이 떨어지는 방식이다.

* **멀티 스레드 IO 서버**
	복수 개의 스레드를 통해 각각의 요청을 동기적으로 처리하는 방식이다. 단일 보다 빠르지만, **요청 자체가 단순 IO 작업 위주일 경우 비효율이 발생할 수도 있다**. 경쟁 조건 등을 잘 해결해야 한다.

* **다중 IO 서버**
	다중 IO 서버는 하나의 싱글 쓰레드를 활용해 여러개의 커넥션을 모니터링 하는 방식으로 동작한다. 일반적으로 이벤트 루프를 활용해 구현된다.

* **다중 IO 멀티 쓰레드 서버**
	위와 같이 다중 IO를 처리하는 쓰레드를 복수개 생성해 처리하는 서버이다. 위의 서버에서 코어의 효율성을 더 증대 시키기 위해 사용한다. 요즘은 대부분 이런 방식으로 구축한다.

어떤 서버를 언제 선택하는지가 좋은지는 이전에 [[멀티 스레딩#비동기와 멀티 쓰레딩|범수 식당 이야기]] 을 진행하며 한번 다뤘다. 어떤 웹서버가 적절한지는 위의 내용을 참고해 적절히 선택하면 된다.
___
### nginx란?

nginx는 웹서버의 일종으로 아파치 웹서버와 더불어 가장 자주 사용된다. nginx는 주로 리버스 프록시로 사용하거나 정적 파일 캐싱의 용도로 활용된다.

* **리버스 프록시란?**
	**서버 네트워크의 앞단에 위치한 서버로 로드밸런싱, 포트 리워딩, SSL 지원, HTTP 설정 등의 작업을 수행한다. 실제 서버로 요청이 전달되기 이전에 거치는 서버**라고 이해하면 쉽다.

![[Pasted image 20240429112503.png|https://cf-assets.www.cloudflare.com/slt3lc6tev37/3msJRtqxDysQslvrKvEf8x/f7f54c9a2cad3e4586f58e8e0e305389/reverse_proxy_flow.png|600]]

**nginx를 통해 수행할 수 있는 작업들은 다음과 같다.**
* HTTP 커넥션 유지 시간 설정
* POST 요청 시 바디 데이터의 크기 제한
* 특정 URL로 접근하는 요청 포워딩
* **정적 리소스 전달**
* HTTP 응답 압축
* SSL 지원

이외에도 MIME 타입 설정 등 **HTTP와 관련된 모든 요소를 설정하고 조작하는 것이 가능**하다.
___
### nginx 구조 맛보기

**nginx는 한 개 또는 고정된 수의 프로세스만 생성하여 사용하고 Event-Driven 구조를 활용해 한 개의 프로세스에서 많은 IO를 처리하는 형태로 구현돼 있다.** 이에 따라 개별 요청을 처리하는데 적은 양의 리소스로 감당이 가능한 경량 웹서버이다. 

![https://velog.io/@wijihoon123/Nginx%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80](https://obs3dian.s3.ap-northeast-2.amazonaws.com/%EC%9B%B9%EC%84%9C%EB%B2%84%EC%99%80%20WAS%20/%20Pasted%20image%2020240429113303.png)

<u><b>nginx는 pre-fork 방식으로 동작하는 아파치 웹서버와는 대조되는 방식으로 가벼움을 토대로 C10K 문제를 해결했다.</b></u> 아파치 웹서버는 연결을 처리하는 프로세스를 미리 fork 시켜놓고 연결이 들어오면 곧장 미리 만들어뒀던 프로세스를 연결해주는 방식으로 동작했는데, 이는 연결 수가 많아지면 리소스 감당이 불가한 방식이었다.

반면 nginx는 이벤트 루프를 차용한 구조를 활용하면서 리소스 재앙에서 벗어나 가볍게 요청을 처리하는 것이 가능해졌다.

![](https://obs3dian.s3.ap-northeast-2.amazonaws.com/%EC%9B%B9%EC%84%9C%EB%B2%84%EC%99%80%20WAS%20/%20Pasted%20image%2020240429114001.png)

실제 nginx는 마스터 프로세스와 워커 프로세스로 구분돼 동작하는데 마스터 프로세스는 설정 파일을 읽고 워커 프로세스를 생성하는 총 책임자와 같은 프로세스이고 워커 프로세스가 실질적인 커넥션 관리를 진행하는 프로젝트가 된다.

워커 프로세스는 생성시 소켓을 할당 받고 해당 소켓으로 들어오는 커넥션을 처리한다. **하나의 워커 프로세스는 여러 개의 커넥션을 처리하는데 이때 멀티 IO 처리를 위해 이벤트 루프를 활용해 처리한다.** (아마 epoll 등을 적극 활용하지 않을까 싶다...)

워커 프로세스는 비동기로 동작하며 각 커넥션에서 발생한 요청, 신규 연결 요청, 종료 요청 등을 큐에서 하나씩 추출해 처리한다. 
![https://haon.blog/infra/nginx/core-concept/](https://obs3dian.s3.ap-northeast-2.amazonaws.com/%EC%9B%B9%EC%84%9C%EB%B2%84%EC%99%80%20WAS%20/%20Pasted%20image%2020240429114758.png)

이러한 방식은 문제가 존재하는데 **시간이 오래 소요되는 이벤트가 큐에 존재할 경우 다른 이벤트들이 받을 리소스를 빼앗아 전체적인 이벤트 처리 속도가 저하될 수 있다.** 이에 따라 작업이 오래 소요되는 이벤트의 경우 별도의 스레드 풀로 연결해 작업을 처리해 준다.

![https://haon.blog/infra/nginx/core-concept/](https://obs3dian.s3.ap-northeast-2.amazonaws.com/%EC%9B%B9%EC%84%9C%EB%B2%84%EC%99%80%20WAS%20/%20Pasted%20image%2020240429115123.png)
___
### nginx의 장,단점

* **장점**
	**nginx는 사용하는 프로세스의 수가 적기 때문에 컨텍스트 스위칭 비용이 덜 발생한다.** 또한 이러한 가벼운 특징을 활용하면 **동적으로 설정 사항을 변경하는데 용이하게 사용** 할 수 있다. 기존의 커넥션들이 전부 종료되고 나면 해당 프로세스를 종료하고 신규 프로세스로 커넥션을 수신하면 되는데 nginx는 신규 프로세스를 소수개만 생성하면 되므로 설정 변경에 유리하게 동작한다.
	따라서 동적으로 로드밸런싱 등을 조정해줘야 하는 환경에서 유리하게 동작한다.

* **단점**
	아파치 웹서버에 비해 **모듈 호환성이 떨이지는 편**이다. OS 별로 문제가 발생하는 경우도 존재하기 때문에 안정성에 문제가 존재한다.
___
### nginx로 웹 서버 만들기

nginx를 활용해 파일을 요청하고 적절한 처리를 해주는 작업을 수행해보자. 우리가 만들고자 하는 서비스는 기존에 작업 했던 [[싱글 스레드 기반의 초간단 정적 웹서버 만들기]] 프로젝트이다. 과제의 요구 사항을 보면 GET 요청만을 허락하는 index.html, article1.html. article2.html을 구현해주면 된다.

파이썬 코드를 직접 작성해 구현하기 위해서는 파싱 및 응답 처리를 직접 해야 하기에 공수가 제법 많이 들었다. 하지만 nginx를 활용하면 `nginx.conf` 파일을 조정하는 것 만으로 조작이 가능하다. 

일단 brew를 활용해 설치부터 진행해보자.

```bash
brew install nginx
```

이후에는 아래 폴더로 이동해 conf 파일을 연다.
```bash
cd /opt/homebrew/etc/nginx
```

conf 파일에는 nginx의 모든 설정이 저장되며 우리는 여기서 정적 웹서버를 구축할 것이다. 이를 위해선 아래와 같이 작성하면 된다. nginx는 server를 정의한 만큼 설정에 따라 해당 포트를 리슨하는 서버를 생성 해준다.
```bash
 41   server {
 42     listen 8080;
 43     root YOUR FILE PATH; #내 정적파일이 위치한 경로
 44     location / {
 45       autoindex off;
 46     }
 47   }
 48
```

위와 같이 작성하면 8080 포트로 들어오는 요청의 경우 루트 경로가 내 html 파일 폴더의 경로로 설정 돼 이에 따라 적절한 파일을 응답 해준다. `autoindex` 옵션을 on으로 설정하면 `/`로 접속하면 목록 페이지를 전시한다. off면 index.html을 탐색한다.

```bash
nginx -t
```

이제 위의 명령어를 입력해 설정 파일에 오류가 존재하는지 확인한다. 오류가 없다는 응답이 반환되면 터미널에 `nginx`를 입력해 실행한다.

이제 접속을 해보자. 크롬을 통해 접속해도 되고 `curl`을 활용해도 된다.
```bash
 curl -X GET 127.0.0.1:8080/

<!DOCTYPE html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>index</title>
</head>

<body>
    <a href="/article1.html">
        article1
    </a>
    <a href="/article2.html">
        article2
    </a>
</body>

</html>%
```

정상적으로 연결되는 것을 확인할 수 있다. POST 요청을 보내 이에 대한 적절한 예외처리도 됐는지 확인해보자.

```bash
curl -X POST 127.0.0.1:8080/

<html>
<head><title>405 Not Allowed</title></head>
<body>
<center><h1>405 Not Allowed</h1></center>
<hr><center>nginx/1.25.4</center>
</body>
</html>
```

>[!info]
>**nginx를 활용하면 설정 파일을 수정하는 것 만으로 동적 웹서버를 순식간에 구축할 수 있다.**

___
### 정적 웹서버의 한계

정적 웹서버를 활용해 정적 파일을 캐싱 하거나 전달하는 행위가 어떤 방식으로 진행 되는지는 파악했다. 하지만 **정적 웹서버에는 동적인 요청을 처리하지 못한다는 문제가 존재한다. 로그인 기능을 구현한다고 가정해보자. 정적 웹서버의 파일 전달 방식 만으로는 로그인을 구현할 수 없다.**

이와 같은 동적인 요청을 처리하기 위해서는 서버에서 동적 요청을 처리할 응용 프로그램이 동작해야 한다. 이에 따라 등장한 것이 CGI이다.