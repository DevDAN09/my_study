### 출처
* [Oauth란](https://showerbugs.github.io/2017-11-16/OAuth-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C)
___
### 개요
* [[#OAuth이란]]
* [[#OAuth는 왜 만들었을까?]]
* [[#OAuth2.0]]
___
### OAuth이란

**OAuth(Open Authorization)는 인터넷 사용자들이 비밀번호를 공유하지 않고도 제 3의 애플리케이션이나 웹사이트가 사용자의 정보에 접근 할 수 있도록 하는 프로토콜**이다. OAuth를 활용하면 아이디나 비밀번호 등의 개인정보를 직접적으로 저장하지 않고 사용자의 정보를 제공 받는 것이 가능하다. 

네이버나 카카오로 로그인하기 등을 활용해 별도의 아이디나 비밀번호 없이 로그인 또는 회원가입을 한 경험이 다들 존재할 것이다. 이것이 대표적인 OAuth의 응용사례이다.

>[!info]
>**OAuth는 프로토콜로 제 3자가 비밀번호 없이 그들의 정보를 제공 받고 싶을 때 따르는 규칙이다.**

___
### OAuth는 왜 만들었을까?

OAuth의 시작은 옛날 트위터로 거슬러 올라간다. 이전에 별도의 서비스에서 트위터에 저장된 정보를 활용하기 위해선 해당 서비스에서 트위터의 아이디와 비밀번호를 저장하고 있어야 했다. 이는 여러 문제를 발생 시켰는데 아래를 확인해보자.

* 어플리케이션에서 사용자의 트위터 정보를 저장하고 악용이 가능하다.
* 아이디와 비밀번호가 노출되는 횟수가 빈도가 잦아진다.
* 아이디와 비밀번호를 제공함으로써 제3자가 모든 권한을 가질 수 있게 된다.
* 비밀번호 초기화 말고는 해당 어플리케이션의 권한을 폐기할 방법이 없다.

이에따라 **트위터에서 자체적으로 인증서버를 공개해 제 3자 어플리케이션에서 보다 편하게 트위터 내부의 유저 정보를 접근 가능한 구조를 개발했는데 이것이 OAuth의 시작이다.** 초기 OAuth 1.0의 생김새는 아래와 같다.

![500](https://obs3dian.s3.ap-northeast-2.amazonaws.com/OAuth%20/%20Pasted%20image%2020240820172719.png)

OAuth는 토큰을 발급해 관리하는 방식으로 사용자의 id와 비밀번호가 제 3자 어플리케이션에 제공될 필요가 없고 토큰에 대한 정보는 트위터 내부에서 관리 하므로 사용자는 트위터 서버를 통해 언제든지 제 3자 어플리케이션의 권한을 박탈할 수 있게 됐다.

그렇지만 OAuth 1.0은 구현이 번잡했고 http에서의 동작을 보장해야했기에 별도의 hmac 암호화 등을 제공해야 했다. 또한 엑세스 토큰의 유효기간이 존재하지 않는다는 문제점이 존재했다. 

>[!info]
>**OAuth라는 시스템의 등장은 훌륭했으나 손볼 부분들이 조금씩 존재했다.**

___
### OAuth2.0

2.0이 되면서 OAuth는 HTTPS를 필수로 지원하게 변경됐다. 이에따라 기존의 암호화를 위해 사용했던 Hmac 등의 알고리즘으로 부터 자유로워지면서 OAuth 자체의 구조는 단순하게 변경됐다.

2.0은 현재까지도 사용하는 방법이고 오늘을 기준으로 OAuth를 제공하는 모든 서비스는 2.0을 활용한다. 
2.0의 구성을 살펴보자.

* Resource Owner: 사용자
* Client: 제 3자 어플리케이션으로 Resource Server의 정보를 제공 받고 싶어하는 애플리케이션이다.
* Resource Server: 사용자의 정보를 가지고 있는 서버로 카카오나 구글을 말한다.
* Authorization Server: 인증 서버로 사용자가 해당 자원에 대한 권한이 존재하는지 확인하는 서버이다.

이제 각 구성원들이 어떠한 역할을 수행해 인증과정을 마무리 하는지 확인해보자. 아래는 페이코에서 작성한 자료이다.

![](https://obs3dian.s3.ap-northeast-2.amazonaws.com/OAuth%20/%20Pasted%20image%2020240820174323.png)


번잡해보이지만, 내용은 간단하다 하나씩 살펴보자.

1. 사용자가 제 3자 어플리케이션에 로그인 시도를 한다.
2. 서비스는 사용자에게 페이코의 로그인 페이지를 제공한다.
3. 사용자는 페이코의 ID,PW를 페이코 인증서버에 전달한다. (제 3자 서비스가 아닌 페이코에 제공한다)
4. 페이코는 인증이 성사될 경우 인증 코드를 사용자에게 발급한다.
5. 사용자는 인증 코드를 리다이렉트 URL을 통해 서비스에게 전달한다.
6. 서비스는 인증 코드를 기반으로 인증서버로 부터 엑세스 토큰을 발급 받는다.
7. 엑세스 토큰은 서비스 서버에 저장된다.
8. 사용자가 요청시 서비스 서버에 저장된 엑세스 토큰을 통해 페이코 서버로 전송한다.

다음과 같이 정리할 수 있다. 인증 서버를 통해 제 3자 서비스에게는 내 정보를 제공하지 않고 토큰만을 제공한다. 토큰을 통해 제 3자 서비스는 자원 서버에 접근 할 수 있게 된다. 

#### OAuth로 회원가입이 가능한가요?
가능하다. 네이버나 카카오 로그인을 통해 회원가입을 진행해본 경험이 다들 있을 것이다. 이 경우 리소스 서버에서 제공하는 정보만을 토대로 회원가입을 진행하는 것이 가능하다. 따라서 만약 리소스 서버에서 제공하지 못하는 별도의 정보를 입력 받으려면 유저가 추가적으로 정보를 입력하게 해야한다.

흥미롭게 생각해볼 부분은 아이디와 비밀번호 없이 회원가입이 가능하다는 점이다. 인증 자체를 외부에서 진행하기 때문에 서비스 DB에는 아이디나 비밀번호를 저장할 필요가 없다. 다만 이 경우 구분이 어려워 지므로 각 유저 별로 구분되는 인증 코드 등을 저장하는 방식 등을 활용해야 한다.

#### 아이디 비밀번호가 없으면 어떻게 로그인을 해요?
좋은 질문이다. OAuth로 회원가입을 진행한 유저의 경우 아이디와 비밀번호가 서비스 DB에 존재하지 않기 때문에 서비스 단에서 인증을 진행하는 것은 불가능하다. 이에 따라 서비스에서 해당 유저가 존재하는 유저라는 것을 검증하기 위해서는 다음과 같은 과정이 필요하다.

1. 사용자가 인증서버에서 로그인을 진행한다.
2. 인증서버는 서비스 서버로 엑세스 토큰을 발급한다.
3. **엑세스 토큰에 담긴 인증 코드를 서비스 DB에서 탐색한다.**
4. 만약 존재할 경우 존재하는 유저이므로 로그인 성공 처리를 진행한다.

이 과정은 엑세스 토큰과 리프레시 토큰이 모두 만료된 경우에만 발생하는 상황이며 재 로그인이 필요할 경우 내 서비스가 아닌 리소스 서버에서 로그인을 진행해야 한다는 점이 핵심이다.

인증 코드가 존재만해도 로그인 처리를 하다니! **이러면 인증 코드를 브루트포스 방식으로 대입하다 하나 걸리면 해킹이 가능해지는 것이 아닌가?** 라는 생각이 들 수 있다. 이에 따라 서버 단에서는 인증 코드를 포함하는 엑세스 토큰을 검증 작업을 수행한다. 실제로 구글의 경우에는 해당 엑세스 토큰이 실제 구글에서 발급한 토큰인지 검증하는 API도 제공한다.

>[!info]
>**서버는 엑세스 토큰을 검증하고 페이로드에 담겨있는 인증 코드를 토대로 로그인 인증을 실시한다.**

#### 엑세스 토큰과 리프레시 토큰을 왜 서비스 서버가 관리해요?
해당 토큰의 발급 대상이 사용자가 아닌 서비스 서버이기 때문이다. OAuth과정에서 발급되는 토큰은 해당 서비스 전용으로 발급된 토큰이다. 이에따라 적절한 권한이 부여 돼있다.