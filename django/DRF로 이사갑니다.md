### 들어가며

해당 글은 제가 장고를 처음 공부하며 느낀 감정과 요즘 장고를 쓰면서 느낀 불편했던 점을 위주로 작성했습니다. 글에 감정이 많이 담겨있을 수 있으며 장고에 대한 깊은 이해없이 작성 했으므로 이 글이 꼭 진리는 아니라는 것을 명심해주시면 감사하겠습니다.

### 장고를 선택한 이유

이별 이유를 말하기 이전에는 사귀게 된 계기를 먼저 생각해봐야 한다. 장고와의 만남은 이전으로 거슬러 올라간다. 그러니까 한창 FastAPI를 한번 맛보고 조금 체계적인 웹 프레임워크를 다루고 싶다는 생각이 들었다. DRF라는 선택지도 있었지만, 뭔가 오리지날의 맛을 보고싶다는 생각이 들었다. 

첫 만남은 성공적이었다. 프로젝트 설정부터 마이그레이션을 자동으로 해준다는 점 ORM이 자체 탑재 돼있다는 점. 템플릿 엔진.. SQL 쿼리 인젝션과 CSRF 방지까지 꽤나 마음에 들었다. 하지만 이 마음이 그렇게 오래가지 못했다...

### 장고를 버리게 된 이유

답답했던 점이 한 두개가 아니지만 순차적으로 한 개씩 작성 해본다.
#### 믹스인과 뷰를 활용한 못된 다중상속 구조

로그인 인증이 필요한 뷰를 구현하는 중이었다. 장고는 보일러 플레이트가 많으므로 미리 존재하는 `LoginRequired` 믹스인을 활용하고자 했다. 문제는 이러한 믹스인을 뷰와 함께 상속 받아야 하기 때문에 다중 상속을 활용하는 형태가 권장된다는 것인데, 이 다중 상속이라는 형태가 어지러움을 발생하는 경우가 많다.
자세한 부분은 [[뷰와 믹스인#다중상속이 싫어요]]를 참조하자.
#### 외래키 관리가 어지러움

해당 이슈가 생각보다 큰 비중을 차지했는데, 장고에서 외래키의 id 값을 획득하기 위해서는 다음과 같은 방식으로 코드를 작성해야 한다. 아래와 같이 외래키를 갖는 모델이 존재한다고 해보자.

```python
class Post(models.Model):
    id = models.BigAutoField(primary_key=True)
    title = models.CharField(max_length=50, null=False, blank=False)
    content = models.CharField(max_length=500, null=False)
    author = models.ForeignKey(User, related_name="post", on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
```

장고는 외래키를 생성할 경우 자동으로 컬럼명에 `_id`를 붙인 외래 키 컬럼을 실제 DB에 생성한다. 따라서 인스턴스를 생성하고 `post.author_id`와 같은 방식으로 실제 외래키 필드를 참조하는 것이 가능하긴 하다.
문제는 이 속성이 런타임에서만 유효하기 때문에 IDE는 이를 인식하지 못한다는 것이다.

따라서 외래키 컬럼을 참조하는 상황이 발생하면 항상 빨간줄을 보는 상황이 발생하는데 이게 진짜 세상 열받는다. 이를 해결하기 위해서는 `post.author.id` 와 같은 방식으로 참조를 진행해야 하는데 이러한 방식으로 참조하면 쿼리가 한번 더 발생하는 지옥과 같은 상황이 또 펼져진다. 

나는 아직도 이 문제를 명확히 해결할 방법을 떠올리지 못했고 내 IDE에는 여전히 빨간줄이 떠있다..
#### 리퀘스트 파라미터 검증의 어려움

장고는 패스 파라미터 검증을 URL 디스패쳐 단에서 제공하지만, 쿼리나 바디 파라미터에 대한 검증은 직접 구현해야 한다. 이에 따라서 별도의 검증로직을 구현해야 하는데 그러다 보니 모델이 존재함에도 불구하고 별도의 `pydantic`을 활용해 파라미터를 검증하는 슬픈 상황이 발생하게 된다.

뷰 함수 단에서 필요한 파라미터를 명시하지 못한다는 점이 썩 직관적이지 않고 검증 로직을 별도로 또다시 구현해야 한다는 부분도 마음에 들지 않았다.
#### 뷰 클래스의 한계

이것도 할 말이 많다. 장고는 기본적으로 FBV,CBV 형태로 뷰를 구현하게 되는데 FBV는 정말 리퀘스트의 기초적인 파싱과 모든 처리를 진행해야 하기 때문에 가벼운 작업이 아니면 자주 사용하지 않는다. 이에 따라 클래스 기반의 뷰를 자주 활용하게 되는데 이게 생각보다 문제가 많다.

일단 하나의 뷰 클래스는 각 HTTP 메서드에 대응하는 하나의 메서드만 정의할 수 있다는게  마음에 안든다. 이 경우 내가 뷰 클래스 내부에 게시글 조회 메서드를 게시글 리스트 조회 메서드를 작성하고 싶다면 별개의 클래스를 따로 생성 해줘야만 한다.

이 작업만 하면 다행이지만, 생성된 뷰 클래스를 다시 URL 디스패쳐에 등록해야하고 해당 클래스로 요청이 라우팅 되게 설정해줘야 한다. 나는 게시글 조회와 관련된 GET 함수를 하나 더 추가하고 싶었을 뿐인데 이러한 복잡한 처리를 매번 해줘야 하는 것이다. 

#### 글로벌 예외 핸들러의 부재

장고..에는 글로벌 예외 핸들러가 없다. 미들웨어를 활용해 별도로 정의를 해줘야 한다. 미들웨어를 사용하면 이를 정의할 수는 있지만, 그림이 아름답지는 않다. 별도의 미들웨어 정의 없이 글로벌 핸들러를 정의할 수 있다면 얼마나 좋을까.
#### JSON 직렬화의 불편함

이게 진짜 장고를 떠나게 된 가장 큰 이유이다. 장고는 JSON 직렬화가 무척 불편하다. 장고 ORM은 기본적으로 쿼리셋이라는 객체를 주로 활용하는데 이 녀석이 진짜 직렬화가 어렵다. 장고 자체에서도 직렬화 클래스를 제공하고 커스텀으로 구현할 수도 있지만, 양쪽 다 번거로운 작업이 된다. 
