### 출처
* https://dnr2144.tistory.com/42 (리눅스 PCB)
* https://stackoverflow.com/questions/2483041/what-is-the-difference-between-fork-and-thread (fork, exec)
* 
### 개요
[[#Program, Process]]
[[#PCB]]
[[#PCB in Linux]]
[[#fork & exec]]
[[#Copy On Write]]
[[#fork and exec in shell]]
___
### Program, Process

프로그램이란 코드로 짜여진 다양한 함수들의 집합으로 **소스코드를 컴파일한 결과가 곧 프로그램**이 된다. 예를 들어 *.c 파일을 컴파일하면 a.out이나 *.exe 등의 파일이 생성되고 이것이 곧 프로그램이 된다.

**프로그램은 실행 중이지 않을 때는 생명이 없다. 디스크에 그냥 정적으로 위치해있을 뿐이다**. <u><b>프로세스는 실행돼 메모리에 적재돼있는 프로그램을 말하며 생명을 갖고 있다. </b></u>프로세스는 프로그램과 달리 상태를 갖고 중지되거나 죽을 수 있기 때문에 이를 생명을 갖고 있다고 표현한다. 프로그램을 실행해 생명을 불어넣어주고 관리하는 주체가 바로 OS이다.

프로세스는 하나 이상의 쓰레드를 가지며 프로세스별로 독립적인 메모리 공간을 할당 받는다. 
___
### PCB
<span class="red red-bg">PCB는 OS에서 프로세스를 추상화해 관리하기 위해 사용하는 자료구조이다. PCB에는 프로세스에 관한 모든 정보가 저장되며 OS는 이를 통해 프로세스를 관리한다.</span> PCB는 아무 프로세스에서나 접근 가능하면 안되기에 커널의 데이터 영역에 저장된다.

![](https://velog.velcdn.com/images/curiosity806/post/06d141f2-ff5a-4855-a064-b90f218bc0e2/image.png)
* <b><span class="green green-bg">PCB는 왜 필요할까?</span></b>
	프로세스가 CPU에서 실행될 때는 CPU의 레지스터 내부에 프로세스의 정보가 저장돼 있기 때문에 프로세스의 정보를 별도로 저장할 필요가 없다. 하지만 <b><span class="red-bg red">컨텍스트 스위칭에의해 레지스터에 저장된 데이터가 교체되게 되면 현재 프로세스의 정보를 별도의 형태로 저장할 필요가 발생</span></b>하게 되고 이를 위해 PCB가 만들어졌다.

> [!info]
> <b>PCB는 컨텍스트 스위칭 때문에 존재한다. 스위칭이 없는 멍청한 OS라면 PCB가 필요 없다.</b>

![[Pasted image 20231012231241.png]]

* **PROCESS ID**: 프로세스와 그 자식 프로세스 식별을 위해 사용하는 ID
- **STATE**: 프로세스의 상태를 저장하는 속성
- **PROGRAM COUNTER**: CPU가 다음으로 실행할 기계어를 가리키는 값을 의마한다. 메모리에 적재된 다음 명령어(기계어)의 메모리 위치를 뜻한다.
- **REGISTER INFO**: CPU의 범용 레지스터, 연산 레지스터 등에 있던 값을 의미한다. 
- **SCHEDULING INFO**: 우선순위, 실행시간, CPU 점유시간 등을 저장한다. 
- **OPEN FILE LIST**: 프로세스에서 사용하고 있는 파일 리스트를 저장한다.
- **MEMORY INFO**: 프로세스 내부에서 사용하는 메모리의 위치, 용량, 페이지 테이블 등의 정보를 갖는다.
- **PCB POINTER**: 현재 프로세스의 자원들을 저장한 메모리 위치를 가리키는 포인터를 말한다. 부모/자식 프로세스의 PCB, 메모리, 레지스터에 대한 포인터 등을 말한다.

> [!info]
> **PCB에는 다음과 같은 정보들이 저장되며 이를 통해 프로세스의 상태를 기록한다.**
>

___
### PCB in Linux
* **PCB를 직접 확인해보려면 어떻게 해야할까?**
	<u><b>리눅스 커널에서는 PCB를 task_struct로 구현해 관리한다. 해당 구조체는 커널 영역에 존재하며 유저 영역에서 이를 접근하려면 proc 파일 시스템을 통해 제공해주는 간접적인 정보를 통해 확인할 수 있다.</b></u> 아래는 /proc 폴더 아래에 특정한 프로세스의 status 파일의 상태이다. /proc은 실시간으로 값이 변화하며 유저는 이를 통해 현재 프로세스의 상태를 파악할 수 있다.
![[스크린샷 2023-10-13 오전 11.44.37.png]]

직접적으로 task_struct에 접근하고 싶으면 커널을 뜯으면 된다. 해당 구조체는 <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L738">sched.h</a>에 저장돼 있다. task_struct의 세부 구조는 다음과 같다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FUf3qn%2FbtqVdMS5sIN%2F1PKsZV0qVx2CxWgjCAV8h1%2Fimg.png)
크게 6개의 구조체(basic task struct + 5)로 PCB를 구성한다는 것을 확인할 수 있는데, 이는 각각 메모리, 터미널 정보, 사용 중인 파일, 파일 시스템 정보 등이다. 물론 이외에도 쓰레드, 자식 프로세스, 레지스터 등 수많은 속성들이 모여 task_sturct를 만든다.

* **왜 PCB는 구조체의 집합의 형태로 만들어졌을까?**
자식 프로세스 생성을 유리하게 하기 위함이다. 자식 프로세스를 생성할 때 모든 속성을 복사해줄 필요가 있을까? 자식 프로세스가 사용하는 터미널이나, 파일들이 전부 부모 프로세스와 동일할 수 있다.
**따라서 자식 프로세스를 생성할 때 필요한 부분만 별개로 복사하고 싶은 욕구가 발생하게 되고 이에 따라 PCB를 여러개의 속성으로 분리해 관리 가능하게 설계**했다. 
___
### fork & exec
fork, exec 은 프로세스 생성과 관련한 대표적인 시스템 콜이다. 간략하게 각 시스템 콜의 사용 방법을 설명한다.

* **fork**
	**fork를 할 경우 부모 프로세스의 PCB를 그대로 자식 프로세스에 복사** 해준다. **복사를 하는 것이기 때문에 부모와 자식의 메모리는 개별적으로 존재하고 오버헤드가 큰 편**이다. fork는 pid를 반환하며 pid가 0일 경우 자식 프로세스가 실행중이라는 의미가 된다.
	
	fork를 할 경우 자식 프로세스는 레디큐로 편입 되며, 스케줄링 될 경우 부모 프로세스가 fork()를 한 시점부터 실행되는데, 이는 pc와 같은 레지스터 값들 까지 전부 복사하기 때문이다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
    int a = 0;
    int pid;
    pid = fork();
    if (pid == 0) //여기서 부터 자식 프로세스가 실행 
    {
        a += 5;
        printf("Child %d\n", a); //a의 값은 공유되지 않는다.
        printf("Child end\n");
    }
    else
    {
        a += 5;
        printf("Parent %d \n", a);
        printf("Parent end\n");
    }
    return 0;
}
```

* **exec**
	**exec은 현재 프로세스를 다른 프로세스로 뒤집어 씌우는 기능을 수행한다. exec을 실행한 이후로 기존 프로세스의 값들은 전부 신규 실행되는 프로세스의 값으로 대체 된다.**
	exec을 실행한 이후에는 전혀 다른 프로세스가 되므로 이후의 코드 값은 실행되지 않는다.

```c
#include <unistd.h>
#include <stdio.h> 

int main()
{
    printf("execute is\n");
    execl("/bin/ls", "ls", "-al", NULL); //별도의 프로세스가 된다.
    printf("code still alive..?");
    perror("execl is failed\n");
    return 0;
}
```
___
### Copy On Write
앞서 학습한 fork에는 치명적인 단점이 있는데, 프로세스의 내용을 전부 복사하려다 보니 오버헤드가 크다는 것이였다. 이에 따라 [[#PCB]] 에서 설명했듯이 부분적으로만 복사하는 방법을 사용하는데 이를 통해 fork 작업을 가볍게 만든다. 

<span class="red red-bg">Copy On Write의 핵심 아이디어는 데이터의 수정이 발생했을 때 복사를 진행하는 것이다. 만약 부모나 자식 프로세스에서 데이터에 수정을 가한다면 그때 복사를 진행하고 개별적으로 분리된 데이터에 수정을 진행한다.</span> 만약 수정이 없다면 자식은 부모의 메모리 영역을 read-only로 접근해 사용한다.

**힙 영역과 데이터 영역이 COW에의해 관리되고 스텍 영역의 경우 fork 실행과 동시에 복사된다. 코드 영역의 경우 공유해 사용한다.**
___
### fork and exec in shell
```c
+--------+
| pid=7  |
| ppid=4 |
| bash   |
+--------+
    |
    | calls fork
    V
+--------+             +--------+
| pid=7  |    forks    | pid=22 |
| ppid=4 | ----------> | ppid=7 |
| bash   |             | bash   |
+--------+             +--------+
    |                      |
    | waits for pid 22     | calls exec to run ls
    |                      V
    |                  +--------+
    |                  | pid=22 |
    |                  | ppid=7 |
    |                  | ls     |
    V                  +--------+
+--------+                 |
| pid=7  |                 | exits
| ppid=4 | <---------------+
| bash   |
+--------+
    |
    | continues
    V
```
쉘에서는 신규 명령어를 실행할 경우 다음과 같은 순서로 실행된다. fork와 exec을 별개의 작업으로 분리해 실행하는데, 곧장 명령어를 곧장 실행하지 않고 굳이 fork후 exec을 해주는 이유가 뭘까?

* **쉘에서 fork를 사용해 명령어를 처리하는 이유**
	<u>쉘에서 직접 실행하지 않고 fork를 활용해 명령어를 처리하는 이유는 메모리 격리와 다중 작업 등을 위함이다.</u> 만약 쉘 프로세스 내부에서 명령어들도 처리해야 한다면, 해당 명령어를 처리하다 오류가 생길 경우 명령어 뿐 아니라 쉘에게 까지 영향이 갈 확률이 존재한다. 또한 명령어와 쉘이 같은 메모리 공간을 공유함에 따라 문제가 발생할 가능성도 존재한다.

* **쉘에서 fork and exec으로 명령어를 처리하는 이유**
	fork 후에 exec을 실행하면 새로운 프로세스 생성 → 특정 프로세스 대체로 새로운 프로세스 실행이 단숨에 완료된다. spawn이라는 명령어를 만들어서 새 프로세스를 생성할 때 한번에 fork, exec을 동시에 실행해 버리면 편하지 않을까 싶지만, 이 경우 **프로세스 생성 이후 프로세스의 파일 디스크립터 같은 속성 변경에 어려움이 발생**한다. <span class="red red-bg">반대로 fork이후 설정을 변경하고 exec을 하면 설정이 변경된 프로세스에서 원하는 프로그램을 수행하는 것이 가능해진다</span>
	
	<span class="red red-bg">리다이렉션이나 파이프 라인 등이 위의 원리로 구현된다. </span>fork를 통해 프로세스를 생성한 다음 파이프라인이나 리다이렉션이 위치한 파일로 프로세스의 속성을 변경한다. 이후 exec을 통해 프로세스를 대체한 다음 실시한다. 

> [!info]
> **쉘은 명령어를 fork -> exec의 방식으로 처리하고 이는 메모리 격리와 리다이렉션 등을 제공하기 위해 사용한다.**

