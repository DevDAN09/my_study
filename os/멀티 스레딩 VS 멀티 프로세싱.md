### 출처
* https://ko.wikipedia.org/wiki/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9 (멀티스레드 정의)
* https://marcja.wordpress.com/2007/04/06/four-reasons-to-use-multithreading/ (멀티스레드 사용해야할 4가지 이유)
* https://goodgid.github.io/What-is-Multi-Thread/ (멀티 쓰레드의 특징)
___
### 개요
* [[#멀티 쓰레딩이란?]]
* [[#멀티 쓰레드 사용이유]]
* [[#병렬성]]
* [[#경제성]]
* [[#응답성]]
* [[#멀티 쓰레딩 주의 사항]]
* [[#멀티 쓰레드 언제 쓰나요?]]
___
### 멀티 쓰레딩이란?

<b><u>멀티스레딩은 여러 개의 스레드를 활용해 하나의 프로세스를 처리하는 작업을 의미한다. 멀티 스레드를 활용할 경우 한 프로세스 내에 다양한 실행 흐름을 사용해 동시에 여러 작업을 처리할 수 있다. </u></b>

멀티 스레드는 멀티 프로세스와는 차이점을 가지며 이는 쓰레드와 프로세스 간의 차이와 동일하다. 따라서 병렬성으로 인해 멀티 쓰레드나 프로세스를 활용한다면 쓰레드와 프로세스의 특징을 적절히 고민한 후 선정해야 한다.

![[Pasted image 20240102171614.png]]

___
### 멀티 쓰레드 사용이유

멀티 쓰레드를 활용하는 이유는 다음 3가지와 같다.

* **병렬성**
* **경제성**
* **응답성**

#### 병렬성
멀티 쓰레드를 사용할 경우 코어 사용률을 극대화 할 수 있다. 코드를 단순실행할 경우 실행 흐름은 1개 존재하며 해당 쓰레드는 1개의 코어에서 실행되고 나머지 코어들은 대기하게 된다. <span class="red red-bg"><b>쓰레드를 복수개 사용할 경우 각 코어 별로 쓰레드를 할당해 병렬 처리가 가능하다.</b></span> 

이때 주의 할점이 있는데 <b><u>쓰레드를 무한정 늘릴 경우 코어 수에 비해 존재하는 쓰레드가 많아 쓰레드가 대기하는 현상이 발생할 수 있다. 또한 쓰레드를 생성하고 join하는 작업 자체에 오버헤드가 크기 때문에 과한 쓰레드 생성은 성능 저하를 발생 시킬 수도 있다.</u></b>

#### 경제성
쓰레드가 경제적인 이유는 [[쓰레드#쓰레드의 속성|TLB]]가 [[프로세스#PCB|PCB]] 비해 가볍고 이로 인해 생성과 컨텍스트 스위칭이 가볍기 때문이었다. 또한 쓰레드는 메모리 공간의 대다수를 공유 하므로 상호간 통신 또한 단순했다. 쓰레드는 프로세스에 비해 만들기 쉽고, 가벼우며, 상호 작용하기 쉽다는 특징을 갖는다. <span class="red red-bg">멀티 쓰레딩은 이러한 쓰레드의 특징을 그대로 가지며 이로인해 병렬성이나 응답성을 높여야 하는 상황에서 멀티 쓰레드를 활용한다.</span>

#### 응답성
**스레드는 커널 쓰레드와 매핑되며 OS의 스케줄러에 인식된다. 스케줄러는 쓰레드의 상태를 구분해 적절히 스케줄링하고 이를 통해 응답성을 높일 수 있다.** 

예를 들어 웹 브라우저가 싱글 스레드로만 실행된다고 가정해보자. 이 경우 네트워크 IO가 발생하고 있는 시간이면 렌더링 조차 발생하지 않는다. 따라서 현재 처럼 서서히 로딩이 되는 것이 아니라 어떠한 일도 발생하지 않다가 갑자기 완벽한 페이지가 로딩될 것이다.이러한 방식은 유저에게 현재 프로그램의 상태를 명확히 보여주지 못하기에 사용성이 떨어지는 동작 방식이다. 

하지만 멀티 쓰레딩을 활용해 렌더링 쓰레드와 IO 쓰레드를 분리해 실행하면 유저에게 피드백을 줄 수 있다. IO 진행 중 IO 쓰레드의 상태를 파악한 스케줄러가 렌더링 쓰레드를 실행할 것이고 **이로 인해 로딩과 렌더링이 연속적으로 실행돼 유저에게 현재 페이지가 로딩중이라는 피드백을 줄 수 있다.**
![[images_gil0127_post_e77bf094-c662-48ac-ad2e-530d9bd0f781_single.gif]]![[images_gil0127_post_813ea794-6eef-40b4-8042-09a8551082fd_multi.gif]]

* **응답성 조금 더**
	여기서 말하는 응답성은 사용자의 응답성 뿐만 아니라 프로세스 자체에 대한 응답성도 존재한다. 10개의 파일을 순차적으로 읽는 프로세스를 생각해보자. 단일 쓰레드일 경우 10번째 파일은 9번째 파일을 읽고 난뒤에 진행될 것이다. 하지만 쓰레드를 10개 생성해 동시에 진행할 경우 곧장 파일을 읽을 수 있다.

___
### 멀티 쓰레딩 주의 사항

쓰레드를 사용할 때의 주의사항과 동일하다. 임계영역에 접근하며 경쟁 조건이 발생하지 않게 적절한 [[동기화]]를 진행 해줘야만 한다. 아래의 예제를 살펴보자.
```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void *runner(void *param)
{
    int *tid = (int *)param;
    for (int i = 1; i <= 1000; i++)
    {
        printf("%d is running...\n", *tid);
        usleep(1);
    }
    pthread_exit(0);
}

int main()
{
    pthread_t tid, tid2;
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_create(&tid, &attr, runner, &tid);
    pthread_create(&tid2, &attr, runner, &tid2);

    pthread_join(tid, NULL);
    pthread_join(tid2, NULL);
}
```

일반적인 프로그램이라면 각 tid의 값이 출력된 후 종료돼야 하지만, 두 개의 tid 값이 혼재돼 출력되는 것을 확인할 수 있다. **이는 스레드간 스위칭으로 인한 현상으로 tid, tid2를 출력하는 스레드가 교차로 스케줄링 되며 발생하는 현상이다.** 이에 따라 공유 자원인 출력 터미널을 마구 잡이로 접근하며 의도치 않은 결과가 발생한다.
![[스크린샷 2024-01-02 오후 6.14.17.png]]

한가지 상황을 더 생각해보자 쓰레드를 여러개 사용하는 환경에서 원자적 연산을 보장하지 않을 경우 의도치 않은 부분에서 스위칭이 발생하며 문제를 유발할 수도 있다. ([[동기화#일관성이 깨지는 코드|원자성]]을 살펴보자.) <span class="red red-bg">이와 같이 멀티 스레드에선 사용자가 쓰레드의 스위칭 부분을 명확하게 특정하기는 어렵고 이로 인해 이슈가 발생할 수 있다.</span>

* **스위칭을 마음대로 못하면 원자성을 어떻게 보장해요?**
	그렇기 때문에 뮤텍스 같은 요소들이 추가적으로 개발됐다. 원자성이 필요하면 뮤텍스 등을 활용해 락을 구현 하면 된다. ([[동기화#Lock]]을 살펴보자)

___
### 멀티 쓰레드 언제 쓰나요?

이제 우리는 멀티 쓰레드가 무엇인지 어떤 특성을 갖는지를 파악했다. 이젠 어디에 멀티 쓰레드를 활용하면 좋을지 생각해보자. 특징으로 말미암아 생각해보면 멀티 쓰레드는 다음과 같은 상황에 적합하다.

1. **실행 흐름이 복수개 존재해야 하는 상황**
2. **CPU 코어 효율을 더 높여야 하는 상황**
3. **높은 응답성이 필요한 상황** (브라우저 예시를 들었으므로 생략...)
#### 실행 흐름이 복수개 존재해야 하는 상황
웹 서버를 생각해 볼 수 있다. 서버에 접속한 유저는 각기 다른 활동을 진행할 수 있다. 자유롭게 연결을 끊거나 맺을 수 있으며, 어느 페이지로 이동할지도 유저 마음이다. 이에 따라 **각 유저별로 독립적인 상태를 가질 필요가 발생하므로 별도의 PC와 스택을 보유하는 쓰레드를 복수개 사용하는 것이 적합**하다.

#### CPU 코어 효율을 더 높여야 하는 상황
무거운 연산을 하는 경우 멀티 쓰레드를 활용해 처리 속도를 향상 시킬 수 있다. 아래의 코드를 살펴보자.
```c
void *squareElements(void *arg)
{
    ThreadData *data = (ThreadData *)arg;

    for (int i = data->start; i < data->end; ++i)
    {
        data->array[i] *= data->array[i];
    }

    return NULL;
}
...
...
...
  for (int i = 0; i < NUM_THREADS; ++i)
    {
        threadData[i].array = dataArray;
        threadData[i].start = i * (SIZE / NUM_THREADS);
        threadData[i].end = (i + 1) * (SIZE / NUM_THREADS);

        pthread_create(&threads[i], NULL, squareElements, (void *)&threadData[i]);
    }

```
이는 주어진 배열을 제곱하는 함수이다. 이때 연산의 범위를 쓰레드의 수로 나누어 분할 시켜 작업을 진행한다. 쓰레드의 수를 적절히 분할 함에 따라 병렬성이 증가하고 처리 속도가 빨라진다.
___
### 멀티 프로세싱

