#datastructure #자료구조 #트리 #python 

### 출처

* [트리와 순회](https://medium.com/quantum-ant/%ED%8A%B8%EB%A6%AC-tree-cec69cfddb14)
* [트리 개념](https://www.geeksforgeeks.org/introduction-to-tree-data-structure/)
___
### 개요
* [[#트리]]
* [[#트리를 사용하는 이유]]
* [[#이진트리]]
* [[#트리의 순회]]
* [[#순회 구현하기]]
___
### 트리

**==트리는 사이클이 없는 그래프로 하나의 루트노드와 자식 노드로 구성되고 각 노드들은 에지(간선)를 통해 서로를 연결한다.==**  트리는 루트 노드가 존재하고 부모와 자식 관계로 표현이 가능하기 때문에 **계층 구조를 표현할 때 무척 용이하다.** 이때 경유하는 간선의 수를 사용해 트리의 깊이(레벨) 을 표현하는 것도 자연스럽다.

또한 **트리는 여러 서브 트리의 집합으로 형성되기 때문에 재귀적으로 다루기 용이하다.** 각각의 작은 트리는 동일한 형태를 유지하기 때문에 동일한 작업을 반복적으로 진행하기 유리하다.

트리의 데이터는 순차적으로 저장되지 않는다. 이러한 까닭에 트리는 비선형 구조로 간주된다.

![500](https://obs3dian.s3.ap-northeast-2.amazonaws.com/%ED%8A%B8%EB%A6%AC%20/%20Pasted%20image%2020240807160551.png)

>[!info]
**트리는 주로 계층 구조를 나타내기 위해 활용하고 재귀로 접근하기 용이하다** 

___
### 트리를 사용하는 이유

트리는 데이터베이스나 운영체제의 파일 시스템에 주로 활용된다. 파일 시스템의 표현 구조로 트리를 택한 이유는 계층 구조로 데이터를 저장할 필요가 존재했기 때문이다. **계층 구조로 파일 시스템을 구현할 경우 디렉토리에서 파일을 포함하는 행위와 같이 파일들 사이에서 발생하는 관계를 나타내기 용이**하다. 

또한 **계층 구조로 데이터를 저장하면 특정한 계층만 탐색을 하거나 계층 별로 대표 값만을 탐색하면 되기 때문에 탐색 시간을 획기적으로 단축하는 것이 가능**하다. 예를 들어 서브트리를 완전 탐색하지 않고 서브트리의 루트 노드를 파악하는 것만으로도 대략적인 정보를 파악해 효율성을 높일 수 있다.

트리는 삽입과 삭제에서도 이점을 갖는다. 트리는 탐색속도가 빠르기 때문에 데이터를 삽입하거나 삭제할 위치를 찾는 것도 용이하다. 배열을 통해 이러한 구조를 표현했더라면 삭제와 삽입이 발생할 때마다 적절한 위치 탐색을 위해 최악의 경우 배열 전체를 매번 순회해야할 수도 있다.

> [!트리를 쓰는 이유는 계층 구조를 표현하기 위함]
> 계층 구조를 사용하는 이유는 데이터를 계층 별로 접근하고 관리하면 탐색, 삽입, 삭제에 큰 이점이 발생하기 때문이다.

___
### 이진트리

이진트리는 가장 대표적인 트리로 모든 서브트리가 자식을 최대 2개까지 가질 수 있는 트리를 말한다. 이진트리는 다음과 같은 성질을 갖는다.

* n개의 노드가 있는 이진트리는 최소 n-1개의 간선을 갖는다 (루트 제외)
* 높이가 h인 이진트리는 최소 h개 최대 2^(h-1)개의 노드를 가질 수 있다.
* n개의 노드가 존재하는 이진트리의 높이는 최소 log(n + 1)를 반올림한 값이고 최대 n이다.

![500](https://obs3dian.s3.ap-northeast-2.amazonaws.com/%ED%8A%B8%EB%A6%AC%20/%20Pasted%20image%2020240807163812.png)
![500](https://obs3dian.s3.ap-northeast-2.amazonaws.com/%ED%8A%B8%EB%A6%AC%20/%20Pasted%20image%2020240807163806.png)
트리는 배열을 통해 구현할 수도 있지만, 삭제가 발생할 경우 배열 내부에 메모리 낭비가 발생하고 삽입에 어려움이 존재하기 때문에 주로 링크를 통해 표현한다. 이에따라 **일반적으로 트리의 각 노드들은 다른 노드를 가리키는 포인터 값을 보유하고 있다.** 이러한 점으로 인해 트리의 노드 수가 방대해질 경우 메모리 소비량이 막대할 수 있다.

![500](https://obs3dian.s3.ap-northeast-2.amazonaws.com/%ED%8A%B8%EB%A6%AC%20/%20Pasted%20image%2020240807164107.png)

___
### 트리의 순회

트리를 순회하는 행위는 트리의 모든 노드를 한번씩 방문하는 것을 의미한다. 트리의 순회는 그 방법에 따라 순회 순서가 달라지며 각 순회 별로 목적이 다르다. 스택이나 큐와 같은 **선형적 자료구조들은 순회하는 방법이 LIFO 또는 FIFO로 각각 한가지 뿐 이였지만, 트리는 비선형 구조 이기에 다양한 방식으로 순회가 가능**하다.

순회는 순서에 따라 크게 3가지로 구분된다. (왼쪽을 L 현재 노드를 V 우측을 R이라 하자)

* 전위 순회 (preorder): VLR
* 중위 순회 (inorder): LVR
* 후위 순회 (postorder): RVL

#### 전위순회
전위 순회는 현재 노드부터 방문을 하는 방식으로 순회한다. 현재 노드를 방문한 후에 좌측 서브트리를 순회하고 이후 우측 서브트리를 순회한다. 노드를 방문한다는 의미를 명확히 이해해야 하는데, 이는 해당 노드를 **순회 완료로 표기하는 것을 의미**한다. 전위순회는 **루트 노드 부터 시작해 이후 왼쪽 서브트리를 순차적으로 방문한다**

![500](https://obs3dian.s3.ap-northeast-2.amazonaws.com/%ED%8A%B8%EB%A6%AC%20/%20preorder.gif)

**전위 순회는 노드를 순회하는 즉시 방문 처리를 진행하기 때문에 순회 순서가 곧 방문 순서가 된다.** 전위 순회를 진행할 경우 각 서브트리를 계층적으로 접속 하므로 트리의 구조를 파악할 때 용이하다. 하지만 **전위만으로 전체 트리의 구조를 파악하는 것은 어려움이 존재 하므로 중위 순회 값이 별도로 필요**하다. 이때 전위 순회를 통해 얻은 루트 값을 기반으로 왼쪽과 오른쪽의 서브트리를 구분한다.

==**전위 순회라는 이름이 붙은 이유는 루트 노드를 항상 먼저 방문하기 때문에 붙은 명칭이다.**==

#### 중위 순회
중위 순회는 루트 노드를 왼쪽 노드를 방문한 이후 방문하기 때문에 중위 순회라는 이름이 붙었다. ==**중위 순회는 왼쪽 서브트리 - 방문 노드 - 우측 서브트리 순서로 방문을 진행하기 때문에 BST에서 사용시 트리의 값을 오름차 순으로 획득할 수 있다.**==

![500](https://obs3dian.s3.ap-northeast-2.amazonaws.com/%ED%8A%B8%EB%A6%AC%20/%20inorder.gif)

#### 후위 순회
후위 순회는 루트 노드를 좌측과 우측을 모두 방문한 후에 방문한다. 후위 순회는 자식 노드를 모두 방문한 이후 현재 노드를 방문 처리한다. **후위 순회는 자식을 먼저 모두 방문하는 방식으로 동작하기 때문에 파일의 삭제 등에서 용이하게 활용한다. 하위 파일을 모두 전부 제거한 후에 디렉토리를 제거하는 방식으로 처리할 수 있기 때문이다.**

![500](https://obs3dian.s3.ap-northeast-2.amazonaws.com/%ED%8A%B8%EB%A6%AC%20/%20post.gif)

____
### 순회 구현하기

순회는 모두 재귀나 스택을 활용해 구현할 수 있다. 아래는 재귀의 방식을 활용해 구현한 3가지 순회 코드이다.
스택을 활용해 구현한다면 순회해야하는 순서의 반대로 푸시를 진행하면 된다.


```python
def preorder_traversal(node):
    if node is None:
        return
    print(node.value, end=' ')  # 현재 노드를 방문
    preorder_traversal(node.left)  # 왼쪽 서브트리 방문
    preorder_traversal(node.right)  # 오른쪽 서브트리 방문

def inorder_traversal(node):
    if node is None:
        return
    inorder_traversal(node.left)  # 왼쪽 서브트리 방문
    print(node.value, end=' ')  # 현재 노드를 방문
    inorder_traversal(node.right)  # 오른쪽 서브트리 방문

def postorder_traversal(node):
    if node is None:
        return
    postorder_traversal(node.left)  # 왼쪽 서브트리 방문
    postorder_traversal(node.right)  # 오른쪽 서브트리 방문
    print(node.value, end=' ')  # 현재 노드를 방문


```