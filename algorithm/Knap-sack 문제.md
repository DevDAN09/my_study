### 출처

* [동적 계획법](https://chanhuiseok.github.io/posts/improve-6/)
* [배낭문제](https://gsmesie692.tistory.com/113)
___
### 개요
* [[#배낭문제]]
* [[#그리디한 접근]]
* [[#다이나믹 접근]]
* [[#구현하기]]
* [[#시간 복잡도]]
* [[#응용하기]]
___
### 배낭문제

배낭문제는 물건의 무게와 가치가 주어지고 담을 수 있는 배낭의 최대 수용 무게가 주어질 때 배낭에 넣을 수 있는 물건들의 가치 합의 최대 값을 구하는 것이 목표이다. 배낭 문제를 처음 접하면 직관적으로 두가지 해결 방법을 떠올릴 수 있다.

___
### 그리디한 접근

그리디한 접근은 무게당 가격이 높은 물건부터 담는 방식이다. 가장 무게당 가격이 높은 물건을 우선으로 해서 담고 남는 무게를 순차적으로 채워나가면 된다. 이는 **물건을 분할해서 담는 것이 가능할 때는 이상적인 풀이 방식이 된다.** 

하지만, 만약 **물건의 분할이 불가능해질 경우 이러한 접근을 통한 풀이가 불가하다.** 가방에 물건을 최대 3KG 담을 수 있고 가격이 10인 5KG물건과 가격이 1인 3KG 물건이 존재한다고 해보자. 물건을 KG 단위로 분할해 담을 수 있다면 그리디한 접근으로 풀이가 가능하지만, **분할이 불가능하다면 가격이 높아도 가방에 넣을 수 없으므로 무의미해진다.**

>[!Info]
>분할이 가능한 배낭 문제의 경우 그리디한 접근이 가능하지만 분할이 불가능한 0-1 배낭 문제는 그리디하게 해결할 수 없다

___
### 다이나믹 접근

0-1 배낭 문제는 dp를 활용해 해결이 가능하다. 배낭 문제를 DP로 풀이가 가능한 이유는 다음과 같다. [[DP]]에서 정리한 DP의 조건을 기준으로 확인해보자.

- **최적 부분 구조(Optimal Substructure)**: 전체 문제의 최적해가 부분 문제의 최적해로부터 구해질 수 있어야 한다.
- **중복되는 부분 문제(Overlapping Subproblems)**: 부분 문제가 중복되어 여러번 반복 계산되어야 한다.

가방의 무게를 어기지 않는 선에서 최대한 많은 가치를 지니는 물건을 담는 것이 가방 문제의 목표이다. 이를 최적 부분구조로 분해할 수 있을지 생각해보자. 가방의 현재 무게를 $W$이라 하고 지금 담고자 하는 물건의 무게와 가치를 $K, V$라 하자 이때 가방안의 무게에 따른 현재 최대 가치는 $P(W)$로 표현된다. 
**따라서 현재 물건을 가방에 담는 것이 맞는지 여부를 판단하기 위해서는 현재 가방의 가치인 $P(W)$과 $P(W -K)+ V$의 값을 비교해야 한다.**

우리는 물건의 수납 여부를 기준으로 가방의 최대 가치를 측정하고 있기 때문에 $P(W)$에 물건 정보를 반영해 식을 생성할 수 있다. 물건 정보를 i라고 하면 **$P(i, W)$는 무게가 $W$이고 i번째 물건을 담거나 담지 않았을 경우의 최대 값으로 정리할 수 있다.** 결과적으로 식은 아래와 같이 정리된다

![](https://obs3dian.s3.ap-northeast-2.amazonaws.com/Knap-sack%20%EB%AC%B8%EC%A0%9C%20/%20Pasted%20image%2020240814232533.png)

무게는 1 ~ 최대 허용량까지 되기 때문에 이를 연속적으로 정의하면 P(1, 1) ~ P(1, MAX_WEIGHT) 까지 값을 정의할 수 있다. 정리하면 사용 가능한 무게가 점진적으로 증가함에 따라 1번 물건의 수납여부가 변경 될 것이고 이에 따른 가방의 가치가 변화하는 것을 연속적으로 계산할 수 있다.

이제 최적 부분 구조에 대한 애기를 다시 상기 시키고 이러한 고민을 해보자. 2번 물건의 수납여부를 고려한 최대 값을 구하기 위해서는 어떻게 해야할까?  2번 물건을 수납할 때 최대 값이 계산되는 상황은 다음과 같다.

* 2번 물건을 안넣는 경우가 최대인 경우
* 1번 물건을 빼고 2번 물건을 넣는 것이 최대인 경우
* 1번과 2번을 다 넣는 경우가 최대인 경우

**여기서 1번 물건을 빼고라는 키워드에 집중해보자.** 1번 물건을 빼고라는 말은 2번 물건의 최대 값을 구할 때 1번 물건과 관련된 값을 반복해서 사용한다는 것이다. 예를 들어 2번 물건의 무게가 2이라고 할 때 $P(2, 5)$를 구하려면 $max(P(1, 5), P(1, 3) + value of 2)$를 수행해야 한다. 이처럼 $P(1, X)$를 활용해 $P(2,Y)$를 구하는 것을 확인할 수 있다. 

**==이를 반복해나가면 결과적으로 부분 해를 통해 최적해를 도출해내는 것이 가능하기 때문에 이는 DP의 특성을 만족시킨다.==**

>[!info]
>**사실 i는 누적되는 값으로 $P(i, W)$는 i번째 물건까지 가방에 수납할지 여부를 끝낸 최적해가 된다.** 

테이블을 통해 접근해보자. 조건은 아래와 같다.

|       | 1번 물건 | 2번 물건 | 3번 물건 | 4번 물건 |
| ----- | ----- | ----- | ----- | ----- |
| W(무게) | 6     | 4     | 3     | 5     |
| V(가치) | 13    | 8     | 6     | 12    |

물건을 집어넣는 경우를 생각해보자.

| i \ W | 1   | 2   | 3   | 4   | 5   | 6   | 7   |     |
| ----- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1     | 0   | 0   | 0   | 0   | 0   | 13  | 13  |     |
| 2     | 0   | 0   | 0   | 8   | 8   | 13  | 13  |     |
| 3     | 0   | 0   | 6   | 8   | 8   | 13  | 14  |     |
| 4     | 0   | 0   | 0   | 8   | 12  | 13  | 14  |     |
$P(3, 7) = max(P(2, 7), P(2, 4) + 6)$ 이때 기존의 1번을 빼고 2번과 3번을 집어 넣는 것이 더욱 큰 값을 갖기 때문에 값을 대체한다. 나머지의 작업도 마찬가지이다.

이때 몇몇 P값의 경우에는 물건의 무게에 따라 반복적으로 사용이 되므로 중복되는 부분문제 조건 또한 만족한다는 것을 확인할 수 있다. 

결론적으로 다음과 같이 정리가 가능하다.

가방 문제는 i라는 물건을 담을지 말지를 결정하는 문제이다. 이때 **i의 수납 여부를 결정하고 얻는 가방의 최대 가치를 $P(i, W)$라고 할때 이는 기존의 물건을 빼고 담았을 때의 최대 값과 담지 않았을 때의 최대 값을 비교 함으로써 연산이 가능하다.** 이 과정이 부분적으로 진행되고 과정에서 얻은 해를 반복적으로 활용하기 때문에 DP의 조건을 만족 시킨다.
___
### 구현하기

가방 문제를 다이나믹 프로그래밍으로 구현하기 위해서는 다음의 절차를 수행하면 된다.

* dp 테이블을 초기화한다.
* 모든 물건에 대해 가방에 담을 수 있는지 여부를 파악한다
* 물건 별로 각 무게에 대응하는 최대 값을 측정한다

코드로 작성하면 아래와 같이 정리할 수 있다. 

무게가 없는 물건도 존재할 수는 있기 때문에 무게 테이블의 시작은 0부터 진행된다. 각 물건 별로 모든 무게에 대한 최대 값을 측정한다. 이때 현재 물건의 무게가 가방에 담을 수 있는 무게 j 보다 크면 현재 가방에 존재하는 모든 물건을 빼도 해당 물건 i는 담을 수 없기 때문에 담지 않고 넘어간다.

```python
MAX_WEIGHT = 7

p = [(6, 13), (4, 8), (3, 6), (5, 12)]
product_count = len(p)

dp = [
    [0 for _ in range(MAX_WEIGHT + 1)] for _ in range(product_count + 1)
]  # w가 0인 경우를 생각해주자

for i in range(1, product_count + 1):
    for weight in range(1, MAX_WEIGHT + 1):
        product_weight, product_value = p[i - 1]
        prev_value = dp[i - 1][weight]  # 이전 최대 값

        if weight < product_weight:
            dp[i][weight] = prev_value  # 물건을 담을 수 없으므로 이전 최대 값으로 설정
        else:
            # 물건 안넣기 vs 현재 물건 넣기
            new_value = dp[i - 1][weight - product_weight] + product_value
            dp[i][weight] = max(prev_value, new_value)
```

for문이 1부터 시작해 해당 숫자까지 진행되는 것을 확인할 수 있는데, 이는 이전 값을 기반으로 추출해야 하는 이슈와 해당 무게까지 포함해야 한다는 점때문에 그렇다. 즉 1번 상품 측정을 위한 0번 결과가 존재해야 하고 한도 무게에 대한 값도 존재해야 하기 때문이라 생각하면 된다.

>[!info]
>dp 테이블에는 모든 상품별 한도 무게까지의 최적해가 전부 기록돼 있어야 한다.

___
### 시간 복잡도

가방 문제의 시간 복잡도는  물건의 수 $N$과 무게의 한도 $W$를 기준으로 $O(NW)$ 가 된다. 이는 기존의 $O(2^N)$ 이던 복잡도를 획기적으로 줄인 방법으로 $W$의 크기가 지나치게 크지 않는 이상 항상 효율적인 접근 방식이다. 기존의 복잡도가 $O(2^N)$ 인 이유는 모든 부분집합을 구한 다음 가장 최대인 경우를 찾는 브루트 포스 방식으로 접근했기 때문이다. 

DP를 적용하며 복잡도를 줄이는데 성공했지만, 이를 선형시간에 해결하는 것은 불가능하다. 이때 최대 복잡도를 polynomial 형태로 표현할 수 없는 이러한 문제들을 np문제라고 부른다.

___
### 응용하기

최대 값을 구하는 방식이 아닌 다른 문제에도 이를 응용하는 것이 가능하다. 이 [문제](https://leetcode.com/problems/partition-equal-subset-sum/description/)를 확인해보자.
문제는 어떠한 집합을 합이 동일한 두 부분집합으로 분할이 가능한지를 파악하면 된다.

이를 가방 문제로 변경하면 다음과 같이 생각할 수 있다.

* 물건은 집합의 원소로 생각한다
* 무게는 부분집합을 통해 생성할 수 있는 합이 된다
* 현재 구해야 하는 합에서 원소의 값을 뺀 결과가 이미 존재한다면 현재 합은 만들 수 있다

```python
def canPartition(self, nums: List[int]) -> bool:
	s = sum(nums)
	if s % 2:
		return False

	target = s // 2
	length = len(nums)
	dp = [[False for _ in range(target + 1)] for _ in range(length + 1)]
	dp[0][0] = True #0번은 만들 수 있으므로 True

	for i in range(1, length + 1):
		for partial_sum in range(target + 1):
			value = nums[i - 1] #원소의 값
			prev_value = dp[i - 1][partial_sum]
			if partial_sum >= value: #현재 합이 원소의 값보다 커야한다
				dp[i][partial_sum] = dp[i - 1][partial_sum - value] or prev_value
			else:
				dp[i][partial_sum] = prev_value

	return dp[length][target]
```

이전까지의 원소 만을 활용해서 현재 합을 만들 수 있거나 현재 합에서 원소 값을 뺀 결과를 캐싱 해뒀다면 생성 가능한 합이 된다. 이를 통해 $O(N * sum(nums)/2)$의 복잡도 안에 문제를 해결하는게 가능해진다.

>[!info]
>이처럼 가방 문제는 **부분집합의 모든 경우를 구해야 할것 같은 문제를 풀이할 때 유용하게 사용할 수 있다. 주요한 것은 점진적으로 부분집합에서 활용하는 원소를 늘려나가면서 캐싱을 진행하는 것**이다.
