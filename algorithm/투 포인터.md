### 출처
* [투포인터 개념](https://blog.encrypted.gg/1004)
* [슬라이딩 윈도우](https://m.blog.naver.com/kks227/220795165570)
___
### 개요
* [[#투 포인터 알고리즘]]
* [[#투 포인터의 구현]]
* [[#투 포인터의 동작]]
* [[#투 포인터의 핵심]]
* [[#구간합이 아니더라도]]
* [[#투 포인터와 슬라이딩 윈도우]]
___
### 투 포인터 알고리즘

==**투 포인터 알고리즘은 두개의 포인트를 지정해 배열의 탐색 복잡도를 획기적으로 낮춰주는 알고리즘**==을 말한다. **투 포인터는 일차원 배열에서 부분 집합을 탐색할 때 사용하기 용이**하다. 

예를 들어 배열 내에 합이 특정 수가 되는 **연속된 부분 집합**을 모두 탐색해야 하는 문제가 존재한다고 생각해보자. 가장 쉽게 접근 하는 방법은 모든 부분 수열을 구한 뒤 각 수열의 합을 구해보는 방식일 것이다.

```python
nums = [1,3,4,2,6]
n = 5 #user num
for i in range(len(nums)):
	sum_ = 0
    for j in range(i, len(nums)):
		sum_ += nums[j]
        if  sum_ == n:
            print(nums[i:j])
```

이는 가장 직관적인 접근 방식이지만, 이와 같은 방법으로 접근할 경우 O(N^2)의 복잡도를 갖게 된다. 코드는 아래와 같은 방식으로 모든 부분 수열을 구하고 이의 합을 구한 뒤 찾으려는 숫자와 비교하는 방식으로 동작한다.

```
i = 0
sum_ = sum(nums[0]), sum(nums[0:1]), ..., sum(nums[0:len(nums)])

i = 1
sum_ = sum(nums[1]), sum(nums[1:2]), ..., sum(nums[0:len(nums)])

i = 2
sum_ = sum(nums[2]), sum(nums[2:3]), ..., sum(nums[2:len(nums)])
```

여기에는 트릭이 하나 숨겨져 있는데  `sum(nums[i:j]) = sum(nums[i-1:j]) - nums[i]` 이라는 점이다. **당연한 이야기 같지만 이를 캐싱하지 않기 때문에 발생하는 연산 비효율이 제법 크다. 예를 들어 `sum(nums[1:4])`  을 구해야 한다면, 이전에 수행한 값을 활용해  `sum(nums[0:4]) - nums[0]`을 할 수도 있지만, 실제 코드에서는 다시금 `sum(nums[1:4])`를 수행하고 있기 때문이다.** 

**==따라서 캐싱을 활용해 복잡도를 줄이는 것 또한 가능하지만, 투 포인터를 활용하면 두 개의 포인터 메모리 영역만으로 문제를 해결할 수 있다.==**

> [!투포인터]
> **투 포인터는 이전까지 탐색한 결과를 두개의 포인터에 기록하는 것으로 O(N) 으로 복잡도를 줄이는 것이 가능하다.**

___
### 투 포인터의 구현

투 포인터는 두개의 포인터를 활용해 구간합의 시작과 끝을 표시하는 방식으로 동작한다. 각각 start, end 포인터가 존재하며 구간의 시작과 끝을 의미한다. **구간은 현재 구간의 합이 찾으려는 값보다 작을 경우 end를 확대해 증가하고 클 경우 start 값을 늘려 구간을 축소한다. 양의 정수 만이 수열에 존재하고 있다 가정하기 때문에 구간 합을 늘리려면 end 값을 늘려야만하고 줄이기 위해선 start 값을 늘려야만 한다**. 아래 코드를 보자.

```python
def find_subarray_with_sum(arr, K):
    n = len(arr)
    start = 0
    current_sum = 0

    for end in range(n): #끝점 이동
        current_sum += arr[end]
        
        while current_sum > K and start <= end: #시작점 이동
            current_sum -= arr[start]
            start += 1
        
        if current_sum == K:
            return (start, end)  # 원하는 수열의 시작과 끝 인덱스 반환
    
    return None  # 합이 K인 수열이 없을 경우

# 예제 사용
arr = [1, 2, 3, 7, 5]
K = 12
result = find_subarray_with_sum(arr, K)
print(result)  # 출력: (2, 4)

```

우리가 궁극적으로 하고 싶은 것은 모든 연속된 구간을 탐색한 후 합이 특정한 수와 일치 하는지를 파악하는 것이다. 이를 위해서는 `nums[stat:end] (start < end)`와 같이 끝나는 점을 기준으로 존재할 수 있는 모든 연속 수열을 확인해야만 한다.  `nums[0:4],nums[1:4],nums[2:4]...`
따라서 각 end 별로 end-1개의 수열이 존재할 수 있고 end는 배열의 길이와 같은 횟수 만큼 반복하기 때문에 일반적인 방법은 N(N-1)이 된다.

**하지만 투포인터를 사용하면 구간의 시작점을 계속해서 재활용할 수 있게 된다.** 이런 상황을 생각해보자. 내가 찾으려고 하는 수는 5이고 `nums[2:4]`의 합이 4라는 것을 알고 있다. 이 경우 합이 작기 때문에 end 값을 5로 증가시켜 부분 수열의 합을 얻어야 한다. 본래라면 이 경우 `nums[0:5],nums[1:5],nums[2:5]...`를 전부 탐색해야 했겠지만, **우리는 start를 통해 2보다 start가 작을 경우 합의 크기가 찾으려는 수보다 크다는 것을 이미 파악하고 있다.**  즉 각 끝점 별로 end-1개 만큼의 수열을 탐색할 필요가 없어진다.

따라서 2보다 start가 작은 경우는 탐색을 진행하지 않을 수 있다.  **==결론적으로 끝점을 옮기는 횟수 N번과 계속해서 끝점을 따라 증가하는 start가 최대로 이동할 수 있는 N번을 더해서 투포인터 알고리즘은 O(2N) 이하의 복잡도를 갖는다.==**
____
### 투 포인터의 동작

투 포인터는 아래와 같은 방식으로 동작한다. 

* 시작 포인터와 끝 포인터는 처음엔 전부 배열의 시작점을 가리킨다.
* 구간 합이 찾는 값 보다 커지면 스타트 포인터를 뒤로 옮겨 구간을 축소한다.
* 구간 합이 찾는 값 보다 작으면 엔드 포인트를 옮겨 구간을 확대한다.
* 시작 포인터와 끝 포인터가 교차 될 때까지 반복한다.

```text hl:21
*과.은 포인터를 의미한다

*.  //처음엔 전부 시작점을 가리킨다
| 1 | 2 | 3 | 4 | 2 | 5 | 3 | 1 | 1 | 2 |
sum = 0

*   . //.은 1을 가리킨다
| 1 | 2 | 3 | 4 | 2 | 5 | 3 | 1 | 1 | 2 |
sum = 1

//구간 합이 찾으려는 수보다 작은 경우 구간을 확장한다
*       .    
| 1 | 2 | 3 | 4 | 2 | 5 | 3 | 1 | 1 | 2 |
sum = 3

//구간 합이 탐색하는 수 보다 커졌다
*           .
| 1 | 2 | 3 | 4 | 2 | 5 | 3 | 1 | 1 | 2 |
sum = 6

//구간 합이 찾으려는 수보다 클 경우 구간을 축소한다
	*        . 
| 1 | 2 | 3 | 4 | 2 | 5 | 3 | 1 | 1 | 2 |
sum = 5
```

이를 통해서 우리는 합의 값이 탐색하는 수와 일치하는 연속하는 부분집합을 찾았다. **주요한 부분은 우리가 연속하는 구간의 합을 구했다는 점이다. 연속하는 구간 합을 축소하기 위해선 앞에서 한칸 씩 줄여가는 수 밖에 없고 확대하기 위해선 뒤에 한칸 씩 늘려가는 수 밖에 없다.** 

만약 연속하지 않는 두 수의 합을 구한다고 생각하면 앞으로 한칸 씩 이동하는 것이 값의 축소를 보장하지 못하고 뒤로 한칸 씩 이동하는 것이 값의 증가를 보장하지 못한다. 

```text

.* //동일하게 동작해보자.
| 1 | 7 | 3 | 4 | 2 | 5 | 3 | 1 | 1 | 2 |

.   *  //끝점을 1로 옮기자
| 1 | 7 | 3 | 4 | 2 | 5 | 3 | 1 | 1 | 2 |
sum = 1

.       * // 5보다 합이 커졌다
| 1 | 7 | 3 | 4 | 2 | 5 | 3 | 1 | 1 | 2 |
sum = 8

	.   *  //여전히 합은 7이다
| 1 | 7 | 3 | 4 | 2 | 5 | 3 | 1 | 1 | 2 |

		.*  //시작 포인터와 끝 포인터가 교차하므로 멈춘다
| 1 | 7 | 3 | 4 | 2 | 5 | 3 | 1 | 1 | 2 |
```

따라서 만약 연속하지 않는 두 수의 합을 투포인터를 통해 탐색하고 싶을 경우 정렬을 통해 앞,뒤로의 이동이 축소와 증가를 보장해야한다. <span class="red red-bg">반면 연속하는 값일 경우 이것이 자연스럽게 보장되므로 별도의 정렬 없이 곧장 투포인터를 활용할 수 있다. 단 배열 안의 모든 원소는 모두 양수여야 한다.</span>

___
### 투 포인터의 핵심

> "그러면 왜 이렇게 시간복잡도를 줄일 수 있는거냐면, 이중 for문에서는 i = 0일 때 j가 0부터 n-1까지 돌고, i = 1일 때 j가 0부터 n-1까지 돌고, 이와 같이 각 i에 대해서 j가 0부터 n-1까지 돕니다. 그리고 이 과정에서 **i = 0일 때 계산하면서 얻은 정보가 i = 1일 때에 전혀 쓰이지가 않습니다. 그런데 투 포인터에서는 i = 0일 때 계산하면서 얻은 정보를 i = 1일 때 활용합니다. 그 정보가 포인터의 이동으로 나타납니다**"

구간 합 문제를 다시 생각해보자. 시작 포인터와 끝 포인터를 활용함으로써 우리는 해당 구간 합을 반복해서 구할 필요 없이 계속해서 재활용할 수 있다.

> [!info]
> **투 포인터에서 연산 효율성이 발생할 수 있는 까닭은 이전의 결과를 재활용하는 속성 때문이다.** 

___
### 구간합이 아니더라도

**투 포인터의 핵심은 특정한 포인터 두개를 활용해서 해당 포인터 사이의 결과를 캐싱하고 계속해서 재활용하는 것이다.** 구간 합이나 연속 합이라는 키워드가 등장할 때만 활용할 수 있는 알고리즘이 아니라는 것을 명심하자.

#### 연속하지 않는 두 수의 합
어떠한 수 n을 정렬된 수열에서 두 수의 합으로 구해야하는 상황을 가정해보자. 수열이 정렬돼 있다면 두 수의 합이 n보다 클때 right 값을 점점 줄이기만 하면 된다. (left를 증가시키면 값이 커지기만 할 뿐이므로) 반대로 작다면 left의 값을 키우며 탐색을 진행하면 된다. 이렇게 할 경우 이전의 탐색 결과를 반영해 값을 키우거나 줄이는 것이 가능해 탐색 효율성이 증가한다.  [문제](https://leetcode.com/problems/sum-of-square-numbers/description/)

```python
def judgeSquareSum(self, c: int) -> bool:
	head, tail = 0, int(math.sqrt(c))
	while head <= tail:
		sum_ = head * head + tail * tail
		if sum_ < c:
			head += 1
		elif sum_ > c:
			tail -= 1
		else:
			return True
	
	return False
```

#### 문자열 탐색
"문자가 중복되지 않는 연속된 부분 문자열의 최대 길이를 구하라" 와 같은 문제에도 투포인터 알고리즘을 활용할 수 있다. 중복이 발생하면 스타트 포인터를 뒤로 밀고 중복이 발생하지 않으면 엔드 포인터를 뒤로 밀어주면 된다.

abcdefag라는 문자열이 존재하면 a는 7번째에서 중복이 발생해 최대 길이가 7이게 된다. 이때 a 다음 b에서 출발하는 **문자열은 8번째 부터 탐색을 진행하면 된다. 7번째까지는 연속된다는 것을 이미 파악했기 때문이다.**
```python
def lengthOfLongestSubstring(self, s: str) -> int:
	max_len = 0
	end = 0
	char_dict = {}
	
	for i, c in enumerate(s):
		if c in char_dict and end <= char_dict[c]:
			end = char_dict[c] + 1 
		else:
			max_len = max(max_len, i - end + 1)
		
		char_dict[c] = i
	return max_len
```
___
### 투 포인터와 슬라이딩 윈도우

위에서 투 포인터를 설명할 때 “연속된”이라는 키워드를 굉장히 강조해가며 설명했다. 마치 투 포인터가 연속되는 수열이나 문자열과 관련된 문제에만 특화된 것 처럼 말이다.

하지만 **투 포인터의 핵심은 두 개의 포인터가 존재한다는 점이지 연속돼야 한다는 것이 아니다. 연속 됨을 강조해야 하는 알고리즘은 슬라이딩 윈도우이다.**

**투 포인터는 굳이 어떠한 연속된 구간을 생성하지 않아도 된다.** 단순히 두 개의 포인터를 활용해 두 요소를 포인팅하는 것도 투 포인터 알고리즘이다.

>[! 정리]
>**투 포인터는 두 개의 포인터를 활용하는 알고리즘**이다. 두 포인터는 어떠한 구간의 시작과 끝으로 사용될 수도 있고 각각의 원소를 가리키는 포인터로 동작할 수도 있다.
>**투 포인터의 핵심은 연산 효율화이다.** 이미 아는 정보를 또 연산할 필요 없이 효율적 탐색을 할 수 있게 해준다. 이때 **포인터가 알고있는 정보를 저장하는 주체**가 된다.
